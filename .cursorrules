# 랜덤 점심 메뉴 룰렛 - Cursor Rules

## 프로젝트 개요

**프로젝트명**: 랜덤 점심 메뉴 룰렛
**설명**: "오늘 점심 뭐 먹지?" 고민을 재미있게 해결하는 원형 휠 룰렛 서비스
**타겟**: 점심 메뉴 선택에 어려움을 겪는 개인 사용자
**핵심 가치**: 재미(Fun), 단순(Simple), 친근(Friendly), 빠름(Fast)

**참고 문서**:
- docs/project-proposal.md - 서비스 기획안
- docs/wireframes.md - UI/UX 와이어프레임
- docs/design-guide.md - 디자인 시스템
- docs/code-architecture.md - 코드 아키텍처

---

## 기술 스택

- **프레임워크**: React 18.2+ with TypeScript 5.3+
- **빌드 도구**: Vite 5.0+
- **스타일링**: CSS Modules
- **상태 관리**: React Hooks + Context API (Redux 사용 금지)
- **테스트**: Vitest + React Testing Library
- **린팅**: ESLint + Prettier
- **배포**: Vercel

---

## 코딩 원칙

### 1. TypeScript 우선
- 모든 코드는 TypeScript로 작성
- `any` 타입 사용 금지 (불가피한 경우 `unknown` 사용 후 타입 가드)
- 모든 컴포넌트 Props는 interface로 정의
- 유틸리티 함수는 명확한 타입 시그니처 필수

### 2. 함수형 프로그래밍
- 함수형 컴포넌트만 사용 (클래스 컴포넌트 금지)
- React Hooks 적극 활용
- 순수 함수 작성 지향
- 불변성 유지 (직접 mutation 금지)

### 3. 명확성 > 간결성
- 코드의 의도가 명확하게 드러나야 함
- 과도한 축약 금지
- 주석은 "왜"를 설명 ("무엇"은 코드로)

### 4. 테스트 가능한 코드
- 비즈니스 로직은 컴포넌트에서 분리
- Custom Hook으로 로직 추출
- 의존성 주입 가능하게 설계

---

## 폴더 구조 규칙

### Feature-Based Organization
기능별로 코드를 그룹화. 타입별 그룹화 금지.

```
src/
├── components/         # 공통 컴포넌트만
│   ├── common/        # Button, Modal 등
│   └── layout/        # Header, Footer 등
├── features/          # 기능별 모듈
│   ├── roulette/
│   │   ├── components/
│   │   ├── hooks/
│   │   ├── utils/
│   │   └── types.ts
│   └── result/
├── hooks/             # 전역 Custom Hooks
├── data/              # 정적 데이터
├── types/             # 전역 타입
├── styles/            # 글로벌 스타일
└── utils/             # 유틸리티 함수
```

### Colocation 원칙
관련 파일은 가까이 배치:
```
Button/
├── Button.tsx
├── Button.module.css
├── Button.test.tsx
└── index.ts
```

### 깊이 제한
- 최대 3-4 레벨까지만 중첩
- 더 깊어지면 구조 재설계 고려

---

## 네이밍 규칙

### 파일명
- **컴포넌트**: PascalCase (예: `RouletteWheel.tsx`)
- **Hooks**: camelCase with `use` prefix (예: `useRoulette.ts`)
- **Utils**: camelCase (예: `random.ts`)
- **Types**: camelCase (예: `menu.ts`)
- **CSS Modules**: `.module.css` suffix (예: `Button.module.css`)
- **Test**: `.test.tsx` or `.test.ts` suffix

### 변수/함수명
- **컴포넌트**: PascalCase (예: `RouletteWheel`)
- **함수/변수**: camelCase (예: `handleSpin`, `isSpinning`)
- **상수**: UPPER_SNAKE_CASE (예: `SPIN_DURATION`, `MENU_COUNT`)
- **Private 함수**: `_` prefix 금지 (export 여부로 구분)
- **Boolean**: `is`, `has`, `should` prefix (예: `isLoading`, `hasError`)
- **이벤트 핸들러**: `handle` prefix (예: `handleClick`, `handleSubmit`)

### 타입/인터페이스
- **Interface**: PascalCase (예: `Menu`, `RouletteState`)
- **Type Alias**: PascalCase (예: `MenuCategory`)
- **Enum**: PascalCase (예: `MenuCategory`)
- **Props Interface**: `ComponentNameProps` (예: `ButtonProps`)
- **Generic**: 단일 대문자 또는 의미있는 이름 (예: `T`, `MenuType`)

---

## 컴포넌트 작성 규칙

### 컴포넌트 구조
표준 순서를 따름:
```typescript
// 1. Imports
import { useState } from 'react';
import styles from './Component.module.css';

// 2. Types
interface ComponentProps {
  // ...
}

// 3. Component
export const Component: React.FC<ComponentProps> = ({ prop1, prop2 }) => {
  // 4. Hooks (순서: state, ref, context, custom hooks, effects)
  const [state, setState] = useState();
  const customHook = useCustomHook();
  
  useEffect(() => {
    // ...
  }, []);

  // 5. Event Handlers
  const handleClick = () => {
    // ...
  };

  // 6. Render Helpers (필요시)
  const renderItem = () => {
    // ...
  };

  // 7. Return
  return (
    <div className={styles.container}>
      {/* JSX */}
    </div>
  );
};
```

### Props 정의
- Interface 사용 (Type 사용 금지)
- Optional props는 `?` 사용
- Default props는 함수 파라미터에서 destructuring으로 설정
- Children은 `React.ReactNode` 타입 사용

```typescript
interface ButtonProps {
  children: React.ReactNode;
  onClick?: () => void;
  variant?: 'primary' | 'secondary' | 'ghost';
  size?: 'sm' | 'md' | 'lg';
  disabled?: boolean;
}

export const Button: React.FC<ButtonProps> = ({
  children,
  onClick,
  variant = 'primary',
  size = 'md',
  disabled = false,
}) => {
  // ...
};
```

### 컴포넌트 분류

#### Presentational Components (표현 컴포넌트)
- UI만 담당
- Props로 데이터 받음
- 상태 최소화 (UI 상태만)
- 재사용 가능
- 위치: `components/common/` 또는 `components/layout/`

#### Container Components (컨테이너 컴포넌트)
- 비즈니스 로직 담당
- 상태 관리
- 데이터 페칭
- 자식 컴포넌트에 Props 전달
- 위치: `features/{feature}/components/`

### 조건부 렌더링
- Early return 선호
- 삼항 연산자는 단순한 경우만
- 복잡한 조건은 변수나 함수로 추출

```typescript
// Good
if (!data) return <Loading />;
if (error) return <Error message={error.message} />;
return <Content data={data} />;

// Avoid
return (
  <>
    {!data ? (
      <Loading />
    ) : error ? (
      <Error message={error.message} />
    ) : (
      <Content data={data} />
    )}
  </>
);
```

---

## TypeScript 규칙

### 타입 정의
- Interface vs Type:
  - Props/State/공개 API: Interface
  - Union/Intersection/Utility: Type
  - 일관성 중요
  
```typescript
// Interface 사용
interface Menu {
  id: string;
  name: string;
  category: MenuCategory;
}

// Type 사용
type MenuId = string;
type MenuOrNull = Menu | null;
```

### Enum vs Union Type
- 고정된 값 집합: Enum
- 타입으로만 사용: Union Type

```typescript
// Enum - 런타임에도 존재
export enum MenuCategory {
  RICE = '밥류',
  SOUP = '국/찌개류',
  NOODLE = '면류',
}

// Union Type - 컴파일 타임에만
type ButtonVariant = 'primary' | 'secondary' | 'ghost';
```

### 타입 가드
- `unknown` 타입 사용 시 타입 가드 필수
- 커스텀 타입 가드 함수 작성

```typescript
function isMenu(value: unknown): value is Menu {
  return (
    typeof value === 'object' &&
    value !== null &&
    'id' in value &&
    'name' in value
  );
}
```

### Generic 사용
- 재사용 가능한 컴포넌트/함수에 활용
- 의미있는 Generic 이름 사용

```typescript
// Good
function getById<T extends { id: string }>(items: T[], id: string): T | undefined {
  return items.find(item => item.id === id);
}

// Avoid
function getById<T>(items: T[], id: string): T | undefined {
  // ...
}
```

---

## React Hooks 규칙

### Hook 사용 순서
컴포넌트 내에서 Hook은 항상 동일한 순서:
1. useState
2. useRef
3. useContext
4. Custom Hooks
5. useEffect (마지막)

### Custom Hook 작성
- `use` prefix 필수
- 명확한 Return 타입 정의
- 하나의 책임만

```typescript
interface UseRouletteReturn {
  isSpinning: boolean;
  rotation: number;
  selectedMenu: Menu | null;
  spin: () => void;
  reset: () => void;
}

export const useRoulette = (): UseRouletteReturn => {
  // ...
  return {
    isSpinning,
    rotation,
    selectedMenu,
    spin,
    reset,
  };
};
```

### useEffect 최적화
- 의존성 배열 정확히 명시
- ESLint exhaustive-deps 규칙 준수
- 정리(cleanup) 함수 필요 시 반드시 작성

```typescript
useEffect(() => {
  const timer = setTimeout(() => {
    // ...
  }, 1000);

  return () => clearTimeout(timer);
}, [dependency]);
```

### Memoization
- 과도한 최적화 지양
- 성능 문제 확인 후 적용
- `React.memo`: Props 변경 적은 컴포넌트
- `useMemo`: 비용 큰 계산
- `useCallback`: 자식에게 전달하는 함수

---

## CSS 규칙

### CSS Modules 사용
- 모든 컴포넌트는 CSS Modules 사용
- Global CSS는 `styles/globals.css`만
- 클래스명: camelCase

```typescript
// Component.module.css
.container {
  display: flex;
}

.primaryButton {
  background: var(--color-primary);
}

// Component.tsx
import styles from './Component.module.css';

<div className={styles.container}>
  <button className={styles.primaryButton}>Click</button>
</div>
```

### CSS 변수 사용
- Design Tokens는 CSS 변수로
- 하드코딩된 값 사용 금지

```css
/* Good */
.button {
  padding: var(--spacing-md) var(--spacing-xl);
  background: var(--color-primary);
  border-radius: var(--radius-md);
}

/* Avoid */
.button {
  padding: 16px 32px;
  background: #FF6B35;
  border-radius: 8px;
}
```

### 클래스명 조합
- `classnames` 라이브러리 사용 금지
- Template literals 사용

```typescript
<button
  className={`${styles.button} ${styles[variant]} ${disabled ? styles.disabled : ''}`}
>
  {children}
</button>
```

### 반응형 디자인
- Mobile First 접근
- 브레이크포인트: 768px (tablet), 1024px (desktop)

```css
/* Mobile (기본) */
.container {
  width: 100%;
}

/* Tablet */
@media (min-width: 768px) {
  .container {
    width: 720px;
  }
}

/* Desktop */
@media (min-width: 1024px) {
  .container {
    width: 960px;
  }
}
```

---

## 상태 관리 규칙

### Local State (useState)
- 컴포넌트 내부에서만 사용
- 단순한 값 관리
- 여러 컴포넌트 공유 필요 시 Context로 이동

### Context API
- 전역 상태 최소화
- Provider는 최상위에 배치
- Context 분리 (관심사별)

```typescript
// RouletteContext.tsx
interface RouletteContextValue {
  isSpinning: boolean;
  selectedMenu: Menu | null;
  spin: () => void;
}

const RouletteContext = createContext<RouletteContextValue | undefined>(undefined);

export const RouletteProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const roulette = useRoulette();
  
  return (
    <RouletteContext.Provider value={roulette}>
      {children}
    </RouletteContext.Provider>
  );
};

export const useRouletteContext = () => {
  const context = useContext(RouletteContext);
  if (!context) {
    throw new Error('useRouletteContext must be used within RouletteProvider');
  }
  return context;
};
```

### 상태 업데이트
- 불변성 유지 필수
- Spread 연산자 활용
- 배열 메서드: map, filter, reduce (push, splice 금지)

```typescript
// Good
setState(prev => ({
  ...prev,
  isSpinning: true,
}));

setMenus(prev => prev.map(menu => 
  menu.id === id ? { ...menu, selected: true } : menu
));

// Avoid
state.isSpinning = true;
setState(state);

menus[0].selected = true;
setMenus(menus);
```

---

## 데이터 구조 규칙

### Menu 타입
모든 메뉴는 다음 인터페이스를 따름:
```typescript
interface Menu {
  id: string;           // 고유 ID (menu-001 형식)
  name: string;         // 메뉴명
  category: MenuCategory; // 카테고리
  description: string;  // 1줄 설명
  emoji: string;        // 이모지 (1개)
  color: string;        // HEX 색상
}
```

### 메뉴 데이터 관리
- 모든 메뉴는 `src/data/menus.ts`에 정의
- 최소 30개 이상 유지
- 카테고리별 균형 유지
- ID는 순차적 (menu-001, menu-002, ...)

### 상수 정의
- `src/data/constants.ts`에 중앙화
- UPPER_SNAKE_CASE 사용
- `as const` assertion 활용

```typescript
export const ANIMATION = {
  SPIN_DURATION: 4000,
  MIN_ROTATIONS: 5,
} as const;
```

---

## 함수 작성 규칙

### 함수 크기
- 한 함수는 한 가지 일만
- 최대 30줄 이내 권장
- 길어지면 분리

### 함수 시그니처
- 매개변수 최대 3개
- 많으면 객체로 전달
- Return 타입 명시

```typescript
// Good
interface SpinOptions {
  duration?: number;
  minRotations?: number;
  onComplete?: () => void;
}

function spin(options: SpinOptions): void {
  // ...
}

// Avoid
function spin(duration, minRotations, onComplete, animate, easing) {
  // ...
}
```

### 순수 함수 지향
- Side effect 최소화
- 동일 입력 → 동일 출력
- 유틸리티 함수는 순수 함수로

```typescript
// Good (순수 함수)
function calculateRotation(currentRotation: number, menuIndex: number): number {
  return currentRotation + menuIndex * 360;
}

// Avoid (side effect)
let rotation = 0;
function calculateRotation(menuIndex: number): number {
  rotation += menuIndex * 360;
  return rotation;
}
```

---

## 에러 처리

### 에러 타입
- 예상 가능한 에러: 명시적 처리
- 예상 불가능한 에러: Error Boundary

### Try-Catch
- 비동기 작업에 필수
- 에러 로깅
- 사용자 친화적 메시지

```typescript
const handleShare = async () => {
  try {
    await navigator.share({
      title: '점심 메뉴',
      text: '오늘 점심은...',
      url: window.location.href,
    });
  } catch (error) {
    if ((error as Error).name !== 'AbortError') {
      console.error('공유 실패:', error);
      alert('공유에 실패했습니다.');
    }
  }
};
```

---

## 성능 최적화 규칙

### 필수 최적화
- Canvas 렌더링: `requestAnimationFrame` 사용
- 리스트 렌더링: `key` prop 필수 (index 금지)
- 이미지: 이모지 사용 (외부 이미지 최소화)

### 선택적 최적화
- 성능 문제 확인 후 적용
- 과도한 최적화 지양
- React DevTools Profiler 활용

```typescript
// 필요시에만 적용
const MemoizedComponent = memo(Component);

const expensiveValue = useMemo(() => {
  return computeExpensiveValue(data);
}, [data]);

const handleClick = useCallback(() => {
  doSomething(value);
}, [value]);
```

### Code Splitting
- 모달은 Lazy Loading
- Route별 코드 분리 (향후)

```typescript
const ResultModal = lazy(() => import('./features/result/components/ResultModal'));

<Suspense fallback={<Loading />}>
  <ResultModal />
</Suspense>
```

---

## 테스트 규칙

### 테스트 작성 원칙
- 모든 유틸리티 함수 테스트 필수
- Custom Hook 테스트 필수
- 컴포넌트는 중요한 것만 (과도한 테스트 지양)

### 테스트 파일 위치
- 테스트 대상 파일과 같은 폴더
- `.test.ts` 또는 `.test.tsx` suffix

### 테스트 구조
```typescript
describe('ComponentName', () => {
  describe('기능/메서드명', () => {
    it('should do something when condition', () => {
      // Arrange
      const expected = 'value';
      
      // Act
      const result = doSomething();
      
      // Assert
      expect(result).toBe(expected);
    });
  });
});
```

### 테스트 네이밍
- 영어 또는 한글 (일관성 중요)
- 명확한 설명
- `should` 패턴 사용

```typescript
// Good
it('should return random menu from list', () => {});
it('메뉴 리스트에서 랜덤 메뉴를 반환해야 한다', () => {});

// Avoid
it('test random', () => {});
it('works', () => {});
```

---

## 접근성 규칙

### 시맨틱 HTML
- 의미있는 HTML 태그 사용
- `<div>` 남용 금지

```typescript
// Good
<header>
  <h1>제목</h1>
</header>
<main>
  <section>내용</section>
</main>
<footer>푸터</footer>

// Avoid
<div>
  <div>제목</div>
  <div>
    <div>내용</div>
  </div>
</div>
```

### ARIA 속성
- 필요한 경우 ARIA 속성 추가
- `role`, `aria-label`, `aria-describedby` 등

```typescript
<canvas
  ref={canvasRef}
  role="img"
  aria-label="점심 메뉴 룰렛"
/>

<button
  aria-label="룰렛 돌리기"
  disabled={isSpinning}
>
  돌리기
</button>
```

### 키보드 네비게이션
- 모든 인터랙티브 요소 포커스 가능
- `tabIndex` 적절히 사용
- 포커스 스타일 명확히

### 색상 대비
- WCAG AA 기준 (4.5:1) 준수
- 색상만으로 정보 전달 금지

---

## Import 규칙

### Import 순서
1. React
2. 외부 라이브러리
3. 내부 절대 경로 (`@/`)
4. 상대 경로
5. CSS/스타일

```typescript
// 1. React
import { useState, useEffect } from 'react';

// 2. 외부 라이브러리
import { Menu } from 'lucide-react';

// 3. 내부 절대 경로
import { Button } from '@/components/common/Button';
import { useRoulette } from '@/features/roulette/hooks/useRoulette';
import { Menu as MenuType } from '@/types/menu';

// 4. 상대 경로
import { SpinButton } from './SpinButton';
import { calculateRotation } from '../utils/rotation';

// 5. CSS
import styles from './Component.module.css';
```

### Path Alias
- `@/` prefix 사용
- tsconfig.json과 vite.config.ts 동기화

```json
// tsconfig.json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
```

---

## Git 규칙

### 커밋 메시지
Conventional Commits 형식:
```
<type>(<scope>): <subject>

<body>

<footer>
```

**Types**:
- `feat`: 새로운 기능
- `fix`: 버그 수정
- `docs`: 문서 수정
- `style`: 코드 포맷팅 (기능 변경 없음)
- `refactor`: 코드 리팩토링
- `test`: 테스트 추가/수정
- `chore`: 빌드 설정, 패키지 등

**예시**:
```
feat(roulette): add spin animation with easing

- Implement requestAnimationFrame for smooth animation
- Add cubic ease-out function
- Update rotation state every frame

Closes #123
```

### 브랜치 전략
- `main`: 배포 브랜치
- `develop`: 개발 브랜치
- `feature/*`: 기능 개발
- `fix/*`: 버그 수정

### PR 규칙
- 작은 단위로 PR
- 리뷰어 지정
- 테스트 통과 확인
- Squash merge 사용

---

## 주석 규칙

### 주석 원칙
- "왜"를 설명 ("무엇"은 코드로)
- 복잡한 로직만 주석
- 주석보다 명확한 코드 우선

### JSDoc
- 공개 API는 JSDoc 작성
- 컴포넌트, 함수, 타입

```typescript
/**
 * 메뉴 리스트에서 랜덤으로 하나를 선택합니다.
 * 
 * @param menus - 선택 가능한 메뉴 배열
 * @returns 랜덤으로 선택된 메뉴
 * 
 * @example
 * const menu = getRandomMenu(menus);
 */
export function getRandomMenu(menus: Menu[]): Menu {
  const randomIndex = Math.floor(Math.random() * menus.length);
  return menus[randomIndex];
}
```

### TODO 주석
- 임시 해결책에 TODO 추가
- 이슈 번호 포함

```typescript
// TODO(#123): 카카오톡 공유 API 연동
// 현재는 콘솔 로그만 출력
console.log('Share to Kakao:', menu);
```

---

## 보안 규칙

### 환경 변수
- 민감한 정보는 환경 변수로
- `.env` 파일은 Git 제외
- 프론트엔드 환경 변수는 `VITE_` prefix

```bash
# .env
VITE_APP_URL=https://example.com
VITE_KAKAO_APP_KEY=your_key
```

### XSS 방지
- 사용자 입력 검증 (현재는 해당 없음)
- `dangerouslySetInnerHTML` 사용 금지
- 외부 스크립트 로드 최소화

---

## 빌드 및 배포 규칙

### 빌드 전 체크리스트
- [ ] ESLint 통과 (`npm run lint`)
- [ ] 테스트 통과 (`npm run test`)
- [ ] 빌드 성공 (`npm run build`)
- [ ] 타입 체크 (`tsc --noEmit`)

### 환경별 설정
- Development: `.env.development`
- Production: `.env.production`
- 환경별 다른 API 키, URL 사용

### 성능 체크
- Lighthouse 점수 90+ 유지
- 번들 크기 모니터링
- Core Web Vitals 준수

---

## 금지 사항

### 절대 하지 말아야 할 것
- ❌ `any` 타입 사용
- ❌ `console.log` 프로덕션 코드에 남기기
- ❌ 인라인 스타일 (style prop)
- ❌ 하드코딩된 색상/크기 값
- ❌ 직접 DOM 조작 (ref 제외)
- ❌ 전역 변수 사용
- ❌ `var` 키워드 사용
- ❌ `==` / `!=` 연산자 (대신 `===` / `!==`)
- ❌ 불필요한 주석
- ❌ 사용하지 않는 import/변수
- ❌ 중복 코드

### 최소화해야 할 것
- ⚠️ `useEffect` 과다 사용
- ⚠️ Context 중첩
- ⚠️ Props drilling (3단계 이상)
- ⚠️ 컴포넌트 크기 (300줄 이상)
- ⚠️ 함수 크기 (30줄 이상)

---

## 코드 리뷰 체크리스트

### 기능
- [ ] 요구사항 충족
- [ ] 예상대로 동작
- [ ] 에러 처리 적절
- [ ] 접근성 준수

### 코드 품질
- [ ] TypeScript 타입 정확
- [ ] 네이밍 명확
- [ ] 구조 논리적
- [ ] 중복 코드 없음
- [ ] 불필요한 복잡성 없음

### 테스트
- [ ] 테스트 작성 (필요시)
- [ ] 테스트 통과
- [ ] 엣지 케이스 고려

### 성능
- [ ] 불필요한 리렌더링 없음
- [ ] 메모리 누수 없음
- [ ] 번들 크기 적절

### 스타일
- [ ] 일관된 포맷팅
- [ ] ESLint 규칙 준수
- [ ] CSS 변수 사용
- [ ] 반응형 동작

---

## 참고 자료

### 공식 문서
- React: https://react.dev/
- TypeScript: https://www.typescriptlang.org/
- Vite: https://vitejs.dev/
- Vitest: https://vitest.dev/

### 코드 스타일 가이드
- Airbnb JavaScript Style Guide
- Google TypeScript Style Guide
- React TypeScript Cheatsheet

### 프로젝트 문서
- docs/project-proposal.md
- docs/wireframes.md
- docs/design-guide.md
- docs/code-architecture.md

---

## 업데이트 이력
- 2026-01-21: 초안 작성
